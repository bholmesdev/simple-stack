---
import { SuspenseStorage, type SuspenseGlobalCtx } from "../src/suspense-context";
import { sleep, trackPromiseState } from "../src/utils";

const globalCtx = Astro.locals.suspense as SuspenseGlobalCtx;
const parentCtx = SuspenseStorage.getStore();

const parentId = parentCtx?.parentId;
const ancestorIds = parentCtx?.ancestorIds ?? [];
const id = globalCtx.getBoundaryId();

console.log(`Suspense ${id} :: parent ${parentId}`);

const thisBoundary = globalCtx.addBoundary(id, parentId);

const contentsThenable = trackPromiseState(
  SuspenseStorage.run(
    { parentId: id, ancestorIds: [...ancestorIds, id] },
    () => Astro.slots.render("default")
  )
);

const SYNC_FLUSH_DEADLINE_MS = 5
await sleep(SYNC_FLUSH_DEADLINE_MS);

type RenderKind = { kind: 'fallback' } | { kind: 'content', content: string }

function getMarkerCommentBegin(id: number) {
  return `<!-- suspense-fallback-begin:${id} -->`
}
function getMarkerCommentEnd(id: number) {
  return `<!-- suspense-fallback-end:${id} -->`
}

// Check if the slot managed to render in time.
// Note that after this point, we shouldn't rely on `thenable.status` --
// we need to make sure that what we do here matches what the middleware does,
// but thenable.status might change if the promise finishes sometime in the meantime,
// which'd result in a race condition.
let renderKind: RenderKind;

function tryReplaceChildFallbacks(content: string) {
  const childBoundaryIds = globalCtx.dependencies.get(id);
  if (!childBoundaryIds) {
    return content;
  }
  for (const childId of childBoundaryIds) {
    const childBoundary = globalCtx.boundaries.get(childId)!;
    const childContents = childBoundary.thenable;
    if (childContents.status === 'fulfilled' && !globalCtx.flushed.has(childId)) {
      const childContentStr = childContents.value;
      if (childContentStr !== null) {
        console.log('replacing child', childId)
        const pat = new RegExp(getMarkerCommentBegin(childId) + '.*?' + getMarkerCommentEnd(childId));
        // TODO: is the didReplace necessary? it should always be true...
        let didReplace = false;
        content = content.replace(
          pat,
          (_) => {
            didReplace = true;
            return childContentStr
          }
        );
        if (didReplace) {
          // we included the contents here, so we don't want it to get emitted again elsewhere.
          globalCtx.markEmittedSync(childBoundary);
        }
        console.log('replacing child', childId, didReplace ? 'success' : 'failed (not found)')
      }
    }
  };
  return content;
}


console.log(`Suspense ${id} :: checking children:`, contentsThenable.status)
switch (contentsThenable.status) {
  case "pending": {
    console.log(`Suspense ${id} :: children will do stuff later, showing fallback`);
    renderKind = { kind: 'fallback' }
    contentsThenable.then(
      async (value) => {
        // children are "ready", but some of them might be fallbacks. suspense returns ~immediately --
        // if we don't do it that way, there's no way to distinguish the async stuff that belongs to this boundary
        // from stuff that belongs to child boundaries.

        // if there's any boundaries below us, give the children one more chance to resolve.
        if (globalCtx.dependencies.get(id)?.size) {
          await Promise.resolve(null);
        }

        // incorporate any resolved child boundaries into our output.
        value = tryReplaceChildFallbacks(value);

        if (parentId === undefined) {
          // there's no boundary above us, so we have to emit ourselves.
          globalCtx.emitAsync(thisBoundary, value);
        } else {
          // there's a parent boundary above us.
          if (globalCtx.flushed.has(parentId)) {
            // parent already flushed, so we have to emit ourselves.
            globalCtx.emitAsync(thisBoundary, value);
          } else {
            // parent hasn't flushed yet. we can just resolve, and it will incorporate us.
            thisBoundary.controller.resolve(value);
          }
        }
      },
      (error) => thisBoundary.controller.reject(error),
    );
    break;
  }
  case "rejected": {
    thisBoundary.controller.reject(contentsThenable.reason);
    throw contentsThenable.reason;
  }
  case "fulfilled": {
    if (import.meta.env.DEV) {
      console.log(
        `Suspense :: slot already resolved, no need to show fallback`
      );
    }
    globalCtx.markEmittedSync(thisBoundary);
    renderKind = { kind: 'content', content: contentsThenable.value }
    break;
  }
}

---

{
  renderKind.kind === 'fallback' ? (
    <>
      <Fragment set:html={getMarkerCommentBegin(id)} />
      <div style="display: contents" data-suspense-fallback={id}>
        <slot name="fallback" />
      </div>
      <Fragment set:html={getMarkerCommentEnd(id)} />
    </>
  ) : (
    <Fragment set:html={renderKind.content} />
  )
}