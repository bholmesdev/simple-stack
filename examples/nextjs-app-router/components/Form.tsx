// Generated by simple:form

import {
	type ComponentProps,
	createContext,
	useContext,
	useState,
} from "react";
import {
	type FieldErrors,
	type FormState,
	type FormValidator,
	formNameInputProps,
	getInitialFormState,
	toSetValidationErrors,
	toValidateField,
	validateForm,
} from "simple-stack-form/module";
import { twMerge } from "tailwind-merge";
import { useFormState as useForStateBase } from "react-dom";

type ValidateFormResult = Awaited<ReturnType<typeof validateForm>> | null;

export function useFormState(
	action: (formData: FormData) => Promise<ValidateFormResult>,
) {
	return useForStateBase(
		async (_: ValidateFormResult, formData: FormData) => action(formData),
		null,
	);
}

export function useCreateFormContext(
	validator: FormValidator,
	fieldErrors?: FieldErrors,
	submitted?: boolean,
) {
	const initial = getInitialFormState({ validator, fieldErrors });
	const [formState, setFormState] = useState<FormState>(initial);

	return {
		value: submitted ? { ...formState, submitStatus: "submitted" } : formState,
		set: setFormState,
		setValidationErrors: toSetValidationErrors(setFormState),
		validateField: toValidateField(setFormState),
	};
}

export function useFormContext() {
	const formContext = useContext(FormContext);
	if (!formContext) {
		throw new Error(
			"Form context not found. `useFormContext()` should only be called from children of a <Form> component.",
		);
	}
	return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function Form({
	children,
	validator,
	fieldErrors,
	name,
	action,
	submitted,
	...formProps
}: {
	validator: FormValidator;
	fieldErrors?: FieldErrors;
	action: (formData: FormData) => void;
	submitted: boolean;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
	const formContext = useCreateFormContext(validator, fieldErrors, submitted);

	return (
		<FormContext.Provider value={formContext}>
			<form
				{...formProps}
				method="POST"
				onSubmit={async (e) => {
					e.preventDefault();
					e.stopPropagation();
					const formData = new FormData(e.currentTarget);
					formContext.set((formState) => ({
						...formState,
						isSubmitPending: true,
						submitStatus: "validating",
					}));
					const parsed = await validateForm({ formData, validator });
					if (parsed.data) {
						formContext.set((formState) => ({
							...formState,
							isSubmitPending: false,
							submitStatus: "submitting",
						}));
						return action(formData);
					}

					formContext.setValidationErrors(parsed.fieldErrors);
				}}
			>
				{name ? <input {...formNameInputProps} value={name} /> : null}
				{children}
			</form>
		</FormContext.Provider>
	);
}

export function Input(inputProps: ComponentProps<"input"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${inputProps.name}" not found in form. Did you use the <Form> component?`,
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;
	return (
		<>
			<input
				className={twMerge("", inputProps.className)}
				onBlur={async (e) => {
					const value = e.target.value;
					if (value === "") return;
					formContext.validateField(inputProps.name, value, validator);
				}}
				onChange={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.target.value;
					formContext.validateField(inputProps.name, value, validator);
				}}
				{...inputProps}
			/>
			{validationErrors?.map((e) => (
				<p key={e}>{e}</p>
			))}
		</>
	);
}
