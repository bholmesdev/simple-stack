---
import { SuspenseStorage, type SuspenseGlobalCtx } from "../src/suspense-context";
import { once, sleep, trackPromiseState } from "../src/utils";

const globalCtx = Astro.locals.suspense as SuspenseGlobalCtx;
const parentCtx = SuspenseStorage.getStore();

const parentId = parentCtx?.parentId;
const ancestorIds = parentCtx?.ancestorIds ?? [];
const id = globalCtx.getBoundaryId();

console.log(`Suspense ${id} :: parent ${parentId}`);

const thisBoundary = globalCtx.addBoundary(id, parentId);

const contentsThenable = trackPromiseState(
  SuspenseStorage.run(
    { parentId: id, ancestorIds: [...ancestorIds, id] },
    () => Astro.slots.render("default")
  )
);

// TODO: figure out what to do with this mess here
//====================================================

function getMarkerCommentBegin(id: number) {
  return `<!-- suspense-fallback-begin:${id} -->`
}
function getMarkerCommentEnd(id: number) {
  return `<!-- suspense-fallback-end:${id} -->`
}

function tryReplaceChildFallbacks(content: string) {
  const childBoundaryIds = globalCtx.children.get(id);
  if (!childBoundaryIds) {
    return content;
  }
  for (const childId of childBoundaryIds) {
    const childBoundary = globalCtx.boundaries.get(childId)!;
    const childContents = childBoundary.thenable;
    console.log(`Suspense ${id} :: attempting to replace child boundary ${childId}:`, childContents.status)
    if (childContents.status === 'fulfilled' && !globalCtx.flushed.has(childId)) {
      const childContentStr = childContents.value;
      if (childContentStr !== null) {
        console.log('replacing child', childId)
        const pat = new RegExp(getMarkerCommentBegin(childId) + '.*?' + getMarkerCommentEnd(childId));
        // TODO: is the didReplace necessary? it should always be true...
        let didReplace = false;
        content = content.replace(
          pat,
          (_) => {
            didReplace = true;
            return typeof childContentStr === 'function' ? childContentStr() : childContentStr
          }
        );
        if (didReplace) {
          // we included the contents here, so we don't want it to get emitted again elsewhere.
          globalCtx.markEmittedSync(childBoundary);
        }
        console.log('replacing child', childId, didReplace ? 'success' : 'failed (not found)')
      }
    }
  };
  return content;
}

async function onChildrenSlotRendered(value: string) {
  // when this gets called,
  // children are "ready", but some of them might be fallbacks. suspense returns ~immediately --
  // if we don't do it that way, there's no way to distinguish the async stuff that belongs to this boundary
  // from stuff that belongs to child boundaries.

  // if there's any boundaries below us, give the children one more chance to resolve.
  // alternatively, if a parent is about to flush, we'd like them to wait for us. 
  const [pendingBatch, didInitiate] = globalCtx.getOrCreateNextBatch({
    boundaryId: id,
    ancestorIds: parentCtx?.ancestorIds,
    duration: SYNC_FLUSH_DEADLINE_MS
  });
  console.log(`Suspense ${id} ::`, didInitiate ? 'initiating batch' : 'joining existing batch');
  let finish: (() => void) | undefined
  if (didInitiate) {
    console.log(`Suspense ${id} ::`, 'waiting to collect...');
    await pendingBatch.collect();
    console.log(`Suspense ${id} ::`, '(initiator) time is up, initiator is flushing NOW');
  } else {
    finish = pendingBatch.register();
  }

  // NOTE: this is kind of like a buffered stream...
  // 1. if parent is pending, and a child completes, we need to buffer the children and make them available to read
  // 2. if parent is already flushed, we need to schedule the child to flush itself
  //    - in particular, when a parent flushes, all of its unbuffered (=pending) children become new "roots" that can emit themselves,
  //      i.e. they switch from pull(ables) to push(ers)
  // would be nicer to have that more visible in the code...
  // i realy think "emit" and "make the contents available for pull" need to get decoupled

  // incorporate any resolved child boundaries into our output.
  // this is done lazily, so that if we're getting incorporated into a parent,
  // we'll look at the promises at the last possible moment, giving them more (micro)ticks to finish.
  const getFinalValue = once(() => tryReplaceChildFallbacks(value));
  
  try {
    console.log(`Suspense ${id} :: about to emit`)
    if (parentId === undefined) {
      // there's no boundary above us, so we have to emit ourselves.
      globalCtx.emitAsync(thisBoundary, getFinalValue());
    } else {
      // there's a parent boundary above us.
      if (globalCtx.flushed.has(parentId)) {
        console.log(`Suspense ${id} :: parent boundary (${parentId}) already flushed`)
        // parent already flushed, so we have to emit ourselves.
        globalCtx.emitAsync(thisBoundary, getFinalValue());
      } else {
        console.log(`Suspense ${id} :: parent boundary (${parentId}) hasn't flushed yet, resolving`)
        // parent hasn't flushed yet. we can just resolve, and it should incorporate us.
        // (note that we're passing a function (NOT a string) on purpose here)
        thisBoundary.controller.resolve(getFinalValue);
        globalCtx.onFlushed(parentId, () => {
          // ...but if the parent didn't end up incorporating us for whatever reason,
          // we'll emit ourselves.
          if (!globalCtx.flushed.has(id)) {
            globalCtx.emitAsync(thisBoundary, getFinalValue())
          }
        })
      }
    }
  } finally {
    if (finish) {
      finish();
    }
  }
}

//====================================================

const SYNC_FLUSH_DEADLINE_MS = 5
await sleep(SYNC_FLUSH_DEADLINE_MS);
type RenderKind = { kind: 'fallback' } | { kind: 'content', content: string }


// Check if the slot managed to render in time.
// Note that after this point, we shouldn't rely on `thenable.status` --
// we need to make sure that what we do here matches what the middleware does,
// but thenable.status might change if the promise finishes sometime in the meantime,
// which'd result in a race condition.
let renderKind: RenderKind;

console.log(`Suspense ${id} :: checking children:`, contentsThenable.status)
switch (contentsThenable.status) {
  case "pending": {
    console.log(`Suspense ${id} :: children will do stuff later, showing fallback`);
    renderKind = { kind: 'fallback' }
    contentsThenable.then(
      onChildrenSlotRendered,
    ).catch((error) => thisBoundary.controller.reject(error));
    break;
  }
  case "rejected": {
    thisBoundary.controller.reject(contentsThenable.reason);
    throw contentsThenable.reason;
  }
  case "fulfilled": {
    if (import.meta.env.DEV) {
      console.log(
        `Suspense :: slot already resolved, no need to show fallback`
      );
    }
    globalCtx.markEmittedSync(thisBoundary);
    renderKind = { kind: 'content', content: contentsThenable.value }
    break;
  }
}

---

{
  renderKind.kind === 'fallback' ? (
    <>
      <Fragment set:html={getMarkerCommentBegin(id)} />
      <div style="display: contents" data-suspense-fallback={id}>
        <slot name="fallback" />
      </div>
      <Fragment set:html={getMarkerCommentEnd(id)} />
    </>
  ) : (
    <Fragment set:html={renderKind.content} />
  )
}